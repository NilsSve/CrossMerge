//****************************************************************************
// $Module type: Package
// $Module name: cSynchronize.pkg
// $Author     : Nils Svedmyr
// Created     : 2001-07-04 @ 14:20
//
// Description
//  Update 'External' db from 'Business' db.
//
// $Rev History
//    2000-12-04  Module header created
//****************************************************************************
Use Windows.pkg
Use cTimer.pkg
Use Dfabout.pkg             // Newwork user name function
Use DfError.pkg
Use CMStatPnl.pkg
Use CheckDSN.pkg            // Check for necessary ODBC DSN's on the computer.
Use cReindex.pkg             // Reindex of Tool files.
Use SyncFuncs.pkg
Use cIndexArray.pkg
Use cIndexArrayFromString.pkg
Use cConstraintsArray.pkg
Use cSynchFlagsArray.pkg
Use cFieldsArray.pkg
Use cDefaultsArray.pkg
Use cTransformMainArray.pkg

// We need these tool files:
Use SncTable.DD
Use SncSys.DD
Use SncLog.DD
Declare_Datafile FlexErrs
// ToDo: *** Check that target & source is not the same file!
Open SncSchem
Open SncTHea
Open SncTRow

//Register_Object oStatusBar
//Register_Object oStatusHelp

//****************************************************************************
// $Module type: CLASS
// $Module name: cSynchronize.pkg
// $Author     : Nils Svedmyr
// Created     : 2001-07-26 @ 16:46
//
// Description :
//
// $Rev History
//    2001-07-26  Module header created
//****************************************************************************

Class cSynchronize is a cObject
    Procedure Construct_Object
        String sValue
        Forward Send Construct_Object
        Property Handle  phoPanel 0
        // Change 2007-04-04 Nils G. Svedmyr.
        // Use of VDF 12 new status_panel logic:
        Property Handle  phoStatPnl        ghoStatusPanel
        Property Handle  phoStatusBar      0
        Property Handle  phoDD             0 // SncTable_DD is set below.
        Property Boolean pbStatPnl         (SncSys.Show_Info) // Use the sentinel to display info.
        Property Boolean pbAutoStart       (SncSys.AutoStart)
        Property Boolean pbAllowCancelSent (SncSys.AllowCancelSent)
        Property Boolean pbDelete_Records       False
        // 2012-06-01 ------------------------------------ Start Nils G. Svedmyr
        Property Boolean pbDeleteSourceRecords  False
        // 2012-06-01 ------------------------------------ Stop Nils G. Svedmyr
        Property Boolean pbConstraints          False
        Property Boolean pbSynchFlags           False
        Property Boolean pbDefaults             False
        Property Boolean pbTransform            False
        Property Boolean pbCheckIntegrity       False
        Property Boolean pbCancelled            False
        Property Boolean pbReindex              False
        Property Boolean pbSynchErr             False
        Property Boolean Error_Processing_State False
        // 2004-06-23 ------------------------------------ Start Nils G. Svedmyr
        Property Boolean pbFromOemToAnsi        False
        Property Boolean pbToOemToAnsi          False
        // 2004-06-23 ------------------------------------ Stop Nils G. Svedmyr
        Property Integer piOldErrorId      Error_Object_Id
        Property Integer piErrorCount      0
        Property Integer piDeletedRecords  0
        Property Integer piCopiedRecords   0
        Property Integer piComparedRecords 0
        Property Integer piUpdatedRecords  0
        Property Integer piIndex           0
        Property String  psToFileDriver    ""
        Property String  psText            ""
        Property String  psSncTableSortText ""
        Property String  psCurrentRecid    ""
        Property String  psFromDataTable   ""
        Property String  psToDataTable     ""
        Get psDataPath of (phoWorkspace(ghoApplication))    to sValue
        Property String  psToolDataPath                        sValue
        Get psProgramPath of (phoWorkspace(ghoApplication)) to sValue
        Property String  psToolProgramPath                     sValue
        //    Property String  psToolWsName      "CrossMerge"
        //    Property String  psDefault_WS      "CrossMerge"
        Property String  psUser            (Network_User_Name(Self)) // DFAbout function.

        Property Integer piDemoType 6        // Licensetype demo is maximized to run for a 100 records
        Property Integer piDemoMax  100

        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 1 // Once for every new record. Used by Callback function.
        Send Ignore_Error of Error_Info_Object 4100      // "Cannot find field". to not trigger error while trying to find a matching field name in ToFile.
        Send Ignore_Error of Error_Info_Object 4121      // "Operation aborted". to not trigger error if user cancel operation while copying all records.

        Object oFromIndex is A cIndexArray
        End_Object

        Object oToIndex is A cIndexArray
        End_Object

        Object oIndexArrayFromString is A cIndexArrayFromString
        End_Object

        Object oConstraintsArray is A cConstraintsArray
        End_Object

        Object oSynchFlagsArray is A cSynchFlagsArray
        End_Object

        Object oFieldsArray is A cFieldsArray
        End_Object

        Object oFieldTypeArray is A Array
            Move Self to Windowindex
            Set phoFieldTypeArray of oFieldsArray to Windowindex
        End_Object

        Object oAppendArray is A Array
            Move Self to Windowindex
            Set phoAppendArray of oFieldsArray to Windowindex
        End_Object

        Object oDefaultsArray is A cDefaultsArray
        End_Object

        Object oTransformMainArray is A cTransformMainArray
        End_Object

        Object oFlashTimer is a cTimer // cFlashTimer
        End_Object

        Object SncSys_DD is A SncSys_DataDictionary
        End_Object

        Object SncLog_DD is A SncLog_DataDictionary
        End_Object

        Object SncTable_DD is A SncTable_DataDictionary
            Delegate Set phoDD to Self
        End_Object

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        If Not (phoPanel(Self)) Begin
            Send Stop_Box "You forgot to set the 'phoPanel' property of the cSynchronize object. Program will be aborted."
            Abort
        End
    End_Procedure

    Procedure DoProcess Handle hoGrid
        Handle hWnd hoStatPnl
        String sText sRegname sItems

        Get SelectedItems of hoGrid to sItems
        If (not(sItems contains "1")) Begin
            Move "No data tables to connected selected. Please make a selection and try again." to sText
            If (pbAutoStart(Self)) Begin
                Send DoLogWork sText ""
            End
            Else Begin
                Send Info_Box sText
            End
            Procedure_Return
        End

        Set pbDelete_Records to SncSys.Delete_Records           // Needs to be done here if user has made changes.
        //    Set phoStatusBar     to (oStatusBar(Self))              // Set it here when object has been created.
        Set phoStatusBar     to (Statusbar_Id(Self))            // Set it here when object has been created.
        Move (Self)          to Error_Object_Id                 // Use internal error_report for this class.
        Set piErrorCount     to 0

        If (phoPanel(Self)) Begin
            Get Window_Handle of (phoPanel(Self)) to hWnd
        End

        Move ("CrossMerge Engine -" * psLicenseType(ghoApplication)) to sText
        If (pbStatPnl(Self)) Begin
            Get phoStatPnl to hoStatPnl
            If hoStatPnl Begin   
                If (not(sText contains "OPEN SOURCE VERSION")) Begin
                    Move ("Registered to:" * psName(ghoApplication) * "No:" * String(psSerial(ghoApplication))) to sRegname
                End 
                Else Begin
                    Move sText to sRegname
                End
                    
                Set License_Text       of hoStatPnl to sRegname
                Set Button_Text        of hoStatPnl to "Cancel"
                Set Allow_Cancel_State of hoStatPnl to (pbAllowCancelSent(Self))
                Send Initialize_StatusPanel  of hoStatPnl sText "Processing:" ""
                Send Start_StatusPanel       of hoStatPnl
            End
        End
        Else Begin
            Set Status_Help to "Connecting data..."
        End

        DateTime dtStartDateTime dtEndDateTime
        Move (CurrentDateTime()) to dtStartDateTime
        Send DoLogWork "Connection started"

        Send DoRunProcess hoGrid                      // MAIN procedure.

        Move (CurrentDateTime()) to dtEndDateTime
        If (pbStatPnl(Self)) Begin
            Send Stop_StatusPanel of (phoStatPnl(Self))
        End
        If (pbCancelled(Self)) Begin
            Send DoLogWork "Process interrupted by user."
        End
        Else Begin
            Send DoLogWork ("Ready. Time Elapsed:" * String(dtEndDateTime - dtStartDateTime))
        End

        If Not (pbAutoStart(Self)) Begin
            If (hWnd And GetForegroundWindow() <> hWnd) ;
                Set pbEnabled of oFlashTimer to True       // Flash Windows statusbar if we are active and minimized.
            If (piErrorCount(Self)) ;
                Send Info_Box (String(piErrorCount(Self)) * "Error(s) encountered while connecting data tables.\nView log for details.") "Connection Error"
            Else Begin
                If (pbCancelled(Self)) Begin
                    Send Info_Box (Trim(SncLog.StatusText)) "Ready"
                End
                Else Begin
                    Send Info_Box ("Connection done.\n" + SncLog.StatusText + "\nView log for details.") "Ready"
                End
            End
            Set pbEnabled of oFlashTimer to False
        End

        Get piOldErrorId to Error_Object_Id         // Reset to standard error object id.
        //    Move hoOldStatPnl to ghoStatusPanel
    End_Procedure

    //-------------------------------------------------------------------------
    // Synchronize selected db's (MAIN LOOP)
    //-------------------------------------------------------------------------
    Procedure DoRunProcess Handle hoGrid
        Handle ho hoDD
        Integer iSize iItem iCols iTables iTable iID iRecords iSet iTmp iFromDbType iToDbType
        Integer iFromFile iToFile iFromIndex iToIndex iRetval iConstrainCount iSynchFlagsCount
        Integer iFromStartField iFromStopField iToStartField iSynchType iSelFieldCount
        Integer iSaveInterval 
        Boolean bChecked bDelete_Records bSysFile bDeleteSourceRecords
        String sText sSelFromFields sSelToFields sFromFieldsToIdx sToFieldsFromIdx sConstraints sSynchFlags
        String sFromLogin sFromOwner sToLogin sToOwner sDefaults sFromDriver sToDriver sFromLayout sToLayout
        String sFromPv sToPv sFromDataTable sToDataTable sFromPath sToPath sSncTableSortText

        Get phoDD to hoDD
        Get CheckedItems of hoGrid to iTables
        Get ItemCount of hoGrid to iSize
        Decrement iSize
        For iItem from 0 to iSize
            Get IsSelected of hoGrid iItem to bChecked
            If (bChecked = True) Begin                                          // procedure after reindex is ready.)
                Set psText to ""
                Set psSncTableSortText to ""
                Clear SncTable
                Get IDValue of hoGrid iItem to iID
                Move iID to SncTable.ID
                Find Eq SncTable.ID
                If (Found = False) Begin
                    Send DoReindexToolFileList hoGrid           // Auto re-index tool files if index error! (Will restart this
                End
                Send Find of hoDD Eq 1                          // Needed by the RDSOpen function.
                Get Field_Current_Value of hoDD Field SncTable.ID to iTmp
                Move giFromFile                       to iFromFile
                Move giToFile                         to iToFile
//                If (iFromFile = 0 And iToFile = 0) Break                 // If both files=0 just skip it. This allows us to add records with TblSetup as
                Move (Trim(SncTable.Text))            to sText
                Move (Trim(SncTable.SortField))       to sSncTableSortText
                Move SncTable.Delete_Records          to bDelete_Records
                Move SncTable.DeleteSourceRecords     to bDeleteSourceRecords
                Move SncTable.FromStartField          to iFromStartField // comments/dividers. Else if one of the files is 0, an error is triggered (and logged).
                Move SncTable.FromStopField           to iFromStopField
                Move SncTable.FromIndex               to iFromIndex
                Move SncTable.ToStartField            to iToStartField
                Move SncTable.ToIndex                 to iToIndex
                Move SncTable.SynchType               to iSynchType
                Move SncTable.SelFieldCount           to iSelFieldCount
                Set pbFromOemToAnsi                   to SncTable.FrFileOemToAnsi
                Set pbToOemToAnsi                     to SncTable.ToFileOemToAnsi
                Move SncTable.ConstrainCount          to iConstrainCount
                Move SncTable.SynchFlagCount          to iSynchFlagsCount
                Move SncTable.FromPv                  to sFromPv
                Move SncTable.ToPv                    to sToPv
                Move SncTable.FromDataTable           to sFromDataTable
                Set psFromDataTable                   to (Trim(sFromDataTable))
                Move SncTable.ToDataTable             to sToDataTable
                Set psToDataTable                     to (Trim(sToDataTable))
                Move SncTable.FromDbType              to iFromDbType
                Move SncTable.ToDbType                to iToDbType
                Move (Trim(SncTable.FromFilePath))    to sFromPath
                Move (Trim(SncTable.ToFilePath))      to sToPath
                Move (Trim(SncTable.Constraints))     to sConstraints
                Move (Trim(SncTable.SynchFlags))      to sSynchFlags
                Move (Trim(SncTable.SelFromFields))   to sSelFromFields
                Move (Trim(SncTable.SelToFields))     to sSelToFields
                Move (Trim(SncTable.FromFieldsToIdx)) to sFromFieldsToIdx
                Move (Trim(SncTable.ToFieldsFromIdx)) to sToFieldsFromIdx
                Move (Trim(SncTable.FromLogin))       to sFromLogin
                Move (Trim(SncTable.FromOwner))       to sFromOwner
                Move (Trim(SncTable.FromDriver))      to sFromDriver
                Move (Trim(SncTable.ToLogin))         to sToLogin
                Move (Trim(SncTable.ToOwner))         to sToOwner
                Move (Trim(SncTable.ToDriver))        to sToDriver
                Set psToFileDriver                    to sToDriver
                Move (Trim(SncTable.ToDefaults))      to sDefaults
                Move (Trim(SncTable.FromLayout))      to sFromLayout
                Move (Trim(SncTable.ToLayout))        to sToLayout
                Move (Trim(SncTable.FromDataTable))   to sFromDataTable
                Move (Trim(SncTable.ToDataTable))     to sToDataTable
                //        Move (Trim(SncTable.Workspace))       to iSaveInterval
                Set pbCheckIntegrity                  to SncTable.CheckIntegrity
                Set pbDelete_Records                  to bDelete_Records
                Set pbDeleteSourceRecords             to bDeleteSourceRecords
                Add 1 to iTable
                Set psText to (Trim(sText))
                Set psSncTableSortText to (Trim(sSncTableSortText))

                Move 1 to iRetval
                If (iFromDbType = EN_DbTypePervasive) Begin
                    Get OpenDDFFile True sFromPath sFromDriver True to iRetval
                    If (not(iRetval)) Begin
                        Error DfErr_Operator ("Could not open Pervasive Meta Data File:" * String(sFromPath) - "\File.ddf")
                    End
                End
                If (not(iRetval)) Break // The Source file could not be opened.
                Get RDSOpenAsFile hoDD True True to iRetval
                If (not(iRetval)) Begin
                    Error DfErr_Operator ("Could not open table:" * String(sFromDataTable))
                End
                If (not(iRetval)) Break // The Source DDF file could not be opened.

                Move 1 to iRetval
                If (iToDbType = EN_DbTypePervasive) Begin
                    Get OpenDDFFile False sToPath sToDriver True to iRetval
                    If (not(iRetval)) Begin
                        Error DfErr_Operator ("Could not open Pervasive Meta Data File:" * String(sToPath) - "\File.ddf")
                    End
                End
                If (not(iRetval)) Break // The Destination DDF file could not be opened.
                Get RDSOpenAsFile hoDD False True to iRetval
                If (not(iRetval)) Begin
                    Error DfErr_Operator ("Could not open table:" * String(sToDataTable))
                End
                If (not(iRetval)) Break // The Destination file could not be opened.

                Get CheckIntegrity iFromFile iToFile sFromLayout sToLayout to iRetval
                If (not(iRetval)) Break // One of the files has a changed database layout.

                Move (oTransformMainArray(Self)) to ho                           // Note: Must precede the defaults array!
                Send DoFillArray of ho SncTable.SncTHea_Count SncTable.ID
                Set pbTransform  to   (SncTable.SncTHea_Count > 0)
                //    send dump of ho

                Move (oDefaultsArray(Self)) to ho                                // Note: Must be after the Transformation constraint_set!
                Send DoFillArray of ho iToFile sDefaults
                Set pbDefaults   to (Length(sDefaults) > 0)
                //    send dump of ho

                Move (oFromIndex(Self)) to ho
                Send DoFillArray  of ho iFromFile iFromIndex                   // Fill index fields array.
                Get_Attribute DF_FILE_IS_SYSTEM_FILE of iFromFile to bSysFile
                If (bSysFile = False) Begin
                    Get Item_Count of ho to iRetval
                    If (not(iRetval)) Begin
                        Error DfErr_Operator ("Index not specified for table" * String(iFromFile))
                    End
                    If (not(iRetval)) Break
                End
                Move (oToIndex(Self)) to ho
                Send DoFillArray  of ho iToFile iToIndex
                Get_Attribute DF_FILE_IS_SYSTEM_FILE of iToFile to bSysFile
                If (bSysFile = False) Begin
                    Get Item_Count of ho to iRetval
                    If (not(iRetval)) Begin
                        Error DfErr_Operator ("Index not specified for table" * String(iToFile))
                    End
                    If (not(iRetval)) Break
                End

                // Index array that keeps From file field numbers to seed the to file index segments with values before a find:
                Move (oIndexArrayFromString(Self)) to ho
                Send DoFillArray of ho sFromFieldsToIdx
                //   Send dump of ho
                Get Item_Count   of ho to iRetval
                If (not(iRetval)) Begin
                    Error DfErr_Operator ("Index Load fields not specified for table" * String(iToFile))
                End
                If (not(iRetval)) Break

                // Fill fields array (Same array for both From and to Fields)
                Move (oFieldsArray(Self)) to ho
                Send DoFillArray of ho iFromFile iFromStartField iFromStopField iToFile iToStartField iSynchType sSelFromFields sSelToFields iSelFieldCount
                Get Item_Count of ho to iRetval
                //  Send dump of ho

                If (not(iRetval)) Begin
                    Error DfErr_Operator ("No fields specified for tables" * String(iFromFile) * "and" * String(iToFile))
                End

                Move (oConstraintsArray(Self)) to ho
                Send DoFillArray     of ho sConstraints iConstrainCount  // Fill constraints array.
                Get BuildConstraints of ho iFromFile to iSet             // iSet=Constraint_Set number.
                //  Send dump of ho
                Set pbConstraints    to iConstrainCount

                Move (oSynchFlagsArray(Self)) to ho
                Send DoFillArray of ho sSynchFlags iSynchFlagsCount  // Fill synch flags array.
                Set pbSynchFlags to iSynchFlagsCount

                If (iRetval) Begin // Then all arrays have been filled properly.
                    Get_Attribute DF_FILE_RECORDS_USED of iFromFile to iRecords
                    If (pbStatPnl(Self)) Begin
                        Set Title_Text   of (phoStatPnl(Self)) to ("Total number of records:" * String(iRecords))
#IF (!@ < 230)
                        Set Message_Text of (phoStatPnl(Self)) to ("Processing:" * ToOem(String(sText)) * "(" + String(iTable) * "of" * String(iTables) + ")")
#ELSE
                        Set Message_Text of (phoStatPnl(Self)) to ("Processing:" * Utf8ToOem(String(sText)) * "(" + String(iTable) * "of" * String(iTables) + ")")
#ENDIF     
                    End
                    Set piComparedRecords to 0
                    Set piUpdatedRecords  to 0
                    Set piCopiedRecords   to 0
                    Set piDeletedRecords  to 0
                    Set pbCancelled       to False

                    Move 0 to Constrain_Found_Count
                    Move 0 to Constrain_Tests_Count
                    Send DoStartUpdate iFromFile iFromIndex iToFile iToIndex iSynchType iSaveInterval bDeleteSourceRecords

                    If (pbConstraints(Self)) Begin
                        Constraint_Set iSet Delete
                        Send DoLogWork ("   Filters (Constraints) in effect:" * String(iConstrainCount) * "Found Count:" * String(Constrain_Found_Count) * "Tests Count:" * String(Constrain_Tests_Count))
                    End
                    Send DoLogWork ("   Total number of Source table records:"  * String(iRecords))
                    Send DoLogWork ("   Compared records:" * String(piComparedRecords(Self)) * "(Field selection type =" * String(iSynchType) + ")")
                    Send DoLogWork ("   Updated records:"  * String(piUpdatedRecords(Self))  * "(Field selection type =" * String(iSynchType) + ")")
                    Send DoLogWork ("   Created records:"  * String(piCopiedRecords(Self))   * "(Field selection type =" * String(iSynchType) + ")")
                    Get_Attribute DF_FILE_RECORDS_USED of iToFile to iRecords
                    Send DoLogWork ("   Total number of Destination table records:"  * String(iRecords))

                    If (pbDeleteSourceRecords(Self) and not(pbCancelled(Self))) Begin
                        Send DoLogWork ("   Deleted Source records:" * String(piDeletedRecords(Self)))
                    End

                    Else If (pbDelete_Records(Self) and not(pbCancelled(Self))) Begin
                        // This index array keeps Tofile field numbers to fill the Fromfile index segments with values before a find:
                        Send DoFillArray of (oIndexArrayFromString(Self)) sToFieldsFromIdx
                        Send DoDeleteOldRecords iFromFile iFromIndex iToFile iToIndex iSynchType
                        Send DoLogWork ("   Deleted Target records:" * String(piDeletedRecords(Self)) * "(Synchtype =" * String(iSynchType))
                    End
                End
                Send DoCloseFiles iFromFile iToFile
            End
            If (not(pbCancelled(Self))) Begin
                Get CancelCheck to iRetval
            End
            If (iRetval) Break
            Send ReDisplayWindow // Procedure in SyncFuncs.pkg
        Loop
    End_Procedure

    Procedure Set Status_Help String sHelp
        Set Status_Help of (phoStatusBar(Self)) to sHelp
    End_Procedure

    Procedure DoReindexToolFileList Handle hoGrid
        Integer iRetval
        String sText
        If (pbStatPnl(Self)) Begin
            Send Stop_StatusPanel of (phoStatPnl(Self))
        End
        Move "Process stopped. Index error in CrossMerge's 'SncTable' data table. It needs to be reindexed." to sText
        Send DoLogWork sText
        If Not (pbAutoStart(Self)) Begin
            Get YesNo_Box (sText * "\nReindex Tool tables now?") to iRetval
            If (iRetval = MBR_No) Begin
                Move "Reindex process of Tool tables cancelled by user." to sText
                Send DoLogWork ("Error:" * sText * "The program was aborted.")
                Send Info_Box (sText * "Program will be aborted.")
                Abort
            End
        End
        Set pbReindex to True
        Get ReindexFiles of oReindex (Self) to sText // Proc in Reindex.pkg.  ho=CallbackObject Returns: String with status text.
        Set pbReindex to False
        Send DoLogWork ("Index Error in Tool table(s) fixed." * sText)
        If Not (pbAutoStart(Self)) Begin
            Send Info_Box sText
        End
        Send DoProcess hoGrid // Re-start the Synchronize process from the beginning!
    End_Procedure

    Procedure DoUpdateSentinelPercentage Integer iFromRecords Integer iFromRecord
        Number nReady nTotal nPerc
        Move iFromRecords            to nTotal
        Move iFromRecord             to nReady
        Move ((nReady/nTotal) * 100) to nPerc
        Send Update_StatusPanel of (phoStatpnl(Self)) ("__PROGRESS__" + String(Integer(nPerc)))
    End_Procedure

    Procedure DoCloseFiles Integer iFromFile Integer iToFile
        Close iFromFile
        Close iToFile
    End_Procedure

    // This can be called for CLI drivers to auto set the record identity.
    Procedure DoSetPrimaryIndex Integer iFile
        Integer iField iIndexes iCount iSegments iIndex iLowSegments iFields iType

        Get_Attribute Df_File_Record_Identity of iFile to iField
        If (iField > 0) Begin
            Get_Attribute Df_Field_Index of iFile iField to iIndex
            Set piIndex to iIndex
        End

        If (iField <= 0)  Begin
            Move 100 to iLowSegments  // Just a high number
            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
            For iCount From 1 to iIndexes
                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iFile iCount to iSegments
                If (iSegments = 1) Break
                If (iSegments < iLowSegments) Begin
                    Move iCount to iIndex // Index with the lowest number of index segments
                    Move iSegments to iLowSegments
                End
            Loop
            If (iSegments = 1) Begin
                Get_Attribute DF_INDEX_SEGMENT_FIELD of iFile iCount 1 to iField
                Move -1 to iIndex
            End
            Else Begin
                Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iFields
                For iCount From 1 to iFields
                    Get_Attribute DF_FIELD_TYPE of iFile to iType
                    If (iType = DF_BCD) Break
                Loop
                Move iCount to iField
            End
        End

        Set_Attribute DF_FILE_RECORD_IDENTITY of iFile to iField
    End_Procedure

    // Purpose: to compare two files and add records in the second file
    //          that doesn't exist and/or update field values in the
    //          second file that has changed in the first file.
    // Syntax:
    //   {From file number} {From-file-index} {To-file-number} {To-file-index} {Synchronization type (=1,2 or 3)}
    // Uses: CompareRecord function and DoCopyRecords, DoCopyManually procedures.
    // Note:
    // An index for sFromIndex and an unique index for sToIndex must exist.
    Procedure DoStartUpdate Integer iFromFile Integer iFromIndex Integer iToFile Integer iToIndex Integer iSynchType Integer iSaveInterval Boolean bDeleteSourceRecords
        Handle  hoToIndex hoIndexArrayFromString
        Integer iChanged iRecords
        Integer iFromField iToField iCount iRetval iSegments iFromRecords iFromRecord
        String  sFromValue sFieldValue sText sDriver
        Boolean bConstraints bFound bSynchFlags bSysFile

        // Check if iFromFile is empty.
        Get_Attribute DF_FILE_RECORDS_USED of iFromFile to iFromRecords
        If Not iFromRecords Begin
            Send DoLogWork "  The Source table was empty. No processing was performed."
            Procedure_Return // Empty From data file. Nothing to do here.
        End

        Move (oToIndex(Self))              to hoToIndex
        Move (oIndexArrayFromString(Self)) to hoIndexArrayFromString

        Get pbConstraints                  to bConstraints
        Get pbSynchFlags                   to bSynchFlags

        // -1, the index to use will be determined automatically from the constraints in force.
        Move -1                            to iFromIndex
        Get_Attribute DF_FILE_DRIVER of iFromFile to sDriver
        If (C_CKDrivers Contains sDriver And sDriver <> DFBTRDRV_ID) Begin
            Send DoSetPrimaryIndex iFromFile    // Class procedure.
        End

        // 2004-09-22 ------------------------------------ Start Nils G. Svedmyr
        Get_Attribute DF_FILE_DRIVER of iToFile to sDriver
        If (C_CKDrivers Contains sDriver And sDriver <> DFBTRDRV_ID) Begin
            Send DoSetPrimaryIndex iToFile    // Class procedure.
        End
        // 2004-09-22 ------------------------------------ Stop Nils G. Svedmyr

        Constrained_Find First iFromFile by iFromIndex    // FIND FIRST SOURCE RECORD:

        // Check if iToFile is empty. If empty copy _all_ records from iFromFile and return.
        Get_Attribute DF_FILE_RECORDS_USED of iToFile to iCount
        If Not iCount Begin
            Send DoCopyManually iFromFile iToFile (False) iFromIndex iSaveInterval bDeleteSourceRecords
            Get_Attribute DF_FILE_RECORDS_USED of iToFile to iRecords
            Set piCopiedRecords                           to iRecords
            Procedure_Return  // ...and we're out of here.
        End

        // 2004-05-14 ------------------------------------ Start Nils G. Svedmyr
        Get_Attribute DF_FILE_IS_SYSTEM_FILE of iToFile to bSysFile
        // 2004-05-14 ------------------------------------ Stop Nils G. Svedmyr

        Get Item_Count of hoToIndex to iSegments

        While (Found)
            // If parameter has been passed to this procedure,
            // only save changed iToFile records after iSaveInterval:
            Move "" to sFromValue
            Clear iToFile
            For iCount From 0 to (iSegments -1) // Load ToFile index segments with values from FromFile:
                Get Integer_Value  of hoIndexArrayFromString Item iCount to iFromField
                Get Integer_Value  of hoToIndex              Item iCount to iToField
                If (iFromField < 0 Or iToField < 0) Begin
                    Error DfErr_Operator ("An error occured while initializing the ToFile index field(s) to find records to delete." * "Index load fields: iFrom field =" * String(iFromField) * "iTo field =" * String(iToField))
                    Procedure_Return
                End
                Get_Field_Value iFromFile iFromField to sFieldValue
                Move (Trim(sFieldValue))             to sFieldValue
                If (bSysFile = False) Begin
                    Set_Field_Value iToFile   iToField to sFieldValue
                End
            Loop

            // All index segments should now be filled; find record:
            If (bSysFile = False) Begin
                VFind iToFile iToIndex Eq
            End
            If (bSysFile = True) Begin
                Clear iToFile
                VFind iToFile 0 Gt
            End

            Move (Found) to bFound     // For some reason the next couple of lines changes the found indicator

            // Display the driver equivivalent of 'Recnum' in status panel:
            Get_Attribute DF_FILE_RECORD_IDENTITY of iFromFile to iFromField // This sets the found indicator?
            Get_Field_Value iFromFile iFromField to sFieldValue
            If (bFound) Begin
                Move "Comparing id:" to sText
            End
            Else Begin
                Move "Creating id:" to sText
            End
#IF (!@ < 230)
            Move (sText  * String(ToOem(sFieldValue))) to sText
#ELSE
            Move (sText  * String(Utf8ToOem(sFieldValue))) to sText
#ENDIF
            If (pbStatPnl(Self)) Begin
                Set Action_Text of (phoStatPnl(Self)) to sText
                Send DoAdvance  of ghoProgressBar
            End
            Else Begin
                Set Status_Help to (sText * "for" * psText(Self))
            End

            // Not found, Create one record:
            If Not bFound Begin
                Send DoCopyManually iFromFile iToFile (True) iFromIndex 0 bDeleteSourceRecords // Create 1 record. Only use selected field numbers
            End

            Else Begin // ToFile record Found; Check if update is needed in ToFile and save changed record.
                Begin_Transaction
                    Move False to Err
                    If (bSysFile = True) Begin
                        VFind iToFile 0 Eq
                    End
                    Get CompareRecords iFromFile iToFile to iChanged
                    Set piComparedRecords to (piComparedRecords(Self) + 1)
                    If (iChanged > 0) Begin  // If iChanged > 0 the record has changed.
                        Set pbSynchErr to False
                        SaveRecord iToFile     // SAVE updated destination record!
                        If Not (pbSynchErr(Self)) Begin
                            Set piUpdatedRecords to (piUpdatedRecords(Self) + 1)
                            If bSynchFlags Begin
                                Send DoUpdateSourceFile iFromFile True // Update Source record with flag fields (if any).
                            End
                        End
                    End
                End_Transaction

                // *** Change start 2012-06-04 Nils G. Svedmyr
                // This is not fully optimized because we might have actually updated the
                // source record above and now we delete it. But it makes the code more
                // readable.
                If (bDeleteSourceRecords = True) Begin
                    Delete iFromFile
                    Set piDeletedRecords to (piDeletedRecords(Self) + 1)
                End

                If (iChanged < 0) Begin
                    If      (iChanged = -1) Begin
                        Error DfErr_Operator "Source table number or index error"
                    End
                    Else If (iChanged = -2) Begin
                        Error DfErr_Operator "Destination table number or index error"
                    End
                    Procedure_Return
                    If (iChanged = -3) Begin
                        Error DfErr_Operator "Could not update a Destination table field" // Continue processing!
                    End
                End
            End

            If Not (pbCancelled(Self)) Begin
                Get CancelCheck to iRetval
            End
            If (pbCancelled(Self)) Begin
                Procedure_Return
            End

//            If (piLicenseType(ghoApplication) = piDemoType(Self) And ((piComparedRecords(Self) + piUpdatedRecords(Self)) >= piDemoMax(Self))) Begin
//                Procedure_Return  // EVAL license. Stop working.
//            End

            Constrained_Find Next

            Add 1 to iFromRecord
            If (pbStatPnl(Self)) Begin
                Send DoUpdateSentinelPercentage iFromRecords iFromRecord
            End
            Send ReDisplayWindow // Procedure in SyncFuncs.pkg
        Loop

    End_Procedure

    // Returns: A positive integer (1) if a field has changed:
    //          A negative integer if an error occured while updating a field value.
    //          False if no change.
    Function CompareRecords Integer iFromFile Integer iToFile Returns Integer
        Integer iChanged iFields iCount iField iPos iFromField iToField iType iToType iRecid iStart
        String  sFromValue sToValue sAppend sFieldValue sFile sField sRecid sFromTestValue sToTestValue
        Handle hoFieldTypeArray hoFieldsArray hoDefaultsArray hoAppendArray hoTransformMainArray hoTransformArray
        Boolean bDefaults

        Get pbDefaults                         to bDefaults
        Get Item_Count of oFieldsArray         to iFields // Contains both Source and Destination table field numbers.
        Move (oFieldsArray(Self))              to hoFieldsArray
        Get phoFieldTypeArray of hoFieldsArray to hoFieldTypeArray
        Move (oDefaultsArray(Self))            to hoDefaultsArray
        Move (oAppendArray(Self))              to hoAppendArray
        If (pbTransform(Self)) Begin
            Move (oTransformMainArray(Self)) to hoTransformMainArray
        End

        // Compare the two field values and update iToFile field value if not same.
        Move 0 to iStart
        For iCount From iStart to (iFields -1)
            Get Integer_Value of hoFieldsArray Item iCount            to iFromField
            Get_Field_Value iFromFile iFromField                      to sFromValue
            Move (Trim(sFromValue))                                   to sFromValue
            Get String_Value of hoAppendArray Item iCount             to sAppend
            If (Trim(sAppend) <> 0) Begin                             // Then field values in Source table have been _appended_ together:
                Move (sAppend + " ")                                    to sAppend
                Get_Attribute DF_FIELD_TYPE of iFromFile iFromField     to iType
                Get Integer_Value of hoFieldsArray Item (iCount + 1)    to iToField
                Get_Attribute DF_FIELD_TYPE of iToFile iToField         to iToType
                Repeat
                    Move (Pos(" ", sAppend))                              to iPos
                    If iPos Begin
                        Move (Left(sAppend, (iPos - 1)))                    to iField
                        Move (Replace((String(iField) + " "), sAppend, '')) to sAppend
                        Get_Field_Value iFromFile iField                    to sFieldValue
                        If (iToType = DF_ASCII Or iType = DF_TEXT) ;
                            Move (String(sFromValue) * String(sFieldValue))   to sFromValue
                        Else ;
                            Move (String(sFromValue) + String(sFieldValue))   to sFromValue
                    End // If iPos Begin
                Until (sAppend = "" Or Not(iPos))
            End // If (Trim(sAppend) > 0) Begin
            If (Err) Begin
                Function_Return (-1)
            End

            Get Integer_Value of hoFieldsArray Item (iCount + 1)      to iToField
            Get_Field_Value iToFile iToField                          to sToValue
            Move (Trim(sToValue))                                     to sToValue
            If (Err) Begin
                Function_Return (-2)
            End

            // Has transformation of field values been used?
            // Function IsFieldInArray returns the array handle with transformation values
            // if this field number. If the field has used transformation values, we call
            // function CheckTransformValues that will substitute to the correct values:
            If (pbTransform(Self)) Begin
                Get IsFieldInArray of hoTransformMainArray iFromField iToField                    to hoTransformArray
                If hoTransformArray Begin
                    Get CheckTransformValues sFromValue sToValue hoTransformArray to sFromValue
                End
            End // If (pbTransform(Self)) Begin

            // Q: Should default values be applied when a field value transformation table is used? Probably not...
            If (Length(sFromValue) = 0 And bDefaults) Begin
                Get String_Value of hoDefaultsArray Item (iToField - 1)         to sFromValue
                If (sFromValue = "|") Begin
                    Move ""                                   to sFromValue
                End
            End // If (Length(sFromValue) = 0 And bDefaults) Begin

            Move sFromValue                                                   to sFromTestValue
            Move sToValue                                                     to sToTestValue
            If (pbFromOemToAnsi(Self) <> pbToOemToAnsi(Self)) Begin
                If (pbFromOemToAnsi(Self) = True) Begin
#IF (!@ < 230)
                    Move (ToOem(sFromValue)) to sFromTestValue
#ELSE
                    Move (Utf8ToOem(sFromValue)) to sFromTestValue
#ENDIF
                End
                Else If (pbToOemToAnsi(Self)   = True) Begin
#IF (!@ < 230)
                    Move (ToOem(sToValue))   to sToTestValue
#ELSE
                    Move (Utf8ToOem(sToValue))   to sToTestValue
#ENDIF
                End
            End // If (pbFromOemToAnsi(Self) <> pbToOemToAnsi(Self)) Begin

            If (sFromTestValue <> sToTestValue) Begin // Not same field value, update iToFile field value:
                //DEBUG: Send DoLogWork ("iFromField = " + String(iFromField) + " sFromValue = " + String(sFromValue) +  " iToField = " + String(iToField) + " sToValue = " + String(sToValue) + " iField = " + String(iField) + " sFieldValue = " + String(sFieldValue)) //
                Move 1 to iChanged
                Set_Field_Value iToFile iToField                                to sFromValue
                If (Err) Begin
                    Function_Return (-3)
                End
                Get_Field_Value iToFile iToField                                to sToValue
                Move (Trim(sToValue))                                           to sToValue

                If (sFromTestValue <> sToTestValue) Begin
                    Get psToDataTable                                             to sFile
                    Get_Attribute DF_FIELD_NAME           of iToFile iToField     to sField
                    Get_Attribute DF_FILE_RECORD_IDENTITY of iToFile              to iRecid
                    Get_Field_Value iToFile iRecid                                to sRecid
                    If (Length(sFromValue) > Length(sToValue)) ;
                        Send DoLogWork ("  Warning! Updated data didn't fit in field/column:" * String(sFile + "." + sField) * "The new value should be:" * String(sFromValue) ;
                    * "but it is:" * String(sToValue) * "Destination Table Record id:" * String(sRecid))
                    Else If (Trim(sFromValue) <> Trim(sToValue)) ;
                        Send DoLogWork ("  Warning! Could not properly update field/column value:" * String(sFile + "." + sField) * "The new value should be:" * String(sFromValue) ;
                        * "but it is:" * String(sToValue) * "Destination Table Record id:" * String(sRecid))
                End
            End
            Increment iCount
        Loop

        Function_Return (iChanged)
    End_Function

    // The Copy_Records command copies record data between database files of the
    // same or different types and/or structures. Data is copied from
    // each field in the source file for which a field of the SAME NAME
    // exists in the target file. Other than name, the fields do not have
    // to have the same size or type attributes, since data conversions
    // will take place automatically.
    // If the record buffer of the {from-file-number} file is active, the
    // copy starts from the active record and proceeds until {num-records}
    // records have been copied to the target file.
    // If the record buffer of the source file is inactive, the copy starts
    // at the first record (based on {index-num}) in the source file.
    // If any copied record contains a field value matching the value in
    // any other record and the field participates in an on-line unique
    // index, Error 28 Duplicate records not allowed in file will be returned,
    // and the record will not be copied.
    // The destination file does not have to contain all the fields that the
    // source file does; whichever ones it has will be copied.

    // DAC Syntax:
    // Copy_Records {from-file-number} to {to-file-number} [{num-records}] ;
    //                                    [Using {index-num}] ;
    //                                    [Callback {callback-object}]
    // Note: If iRecords = 0, all FromFile records will be copied to ToFile.
    Procedure DoCopyRecords Integer iFromFile Integer iToFile Boolean bOne Integer iFromIndex
        String sText
        
        If (not(bOne)) Begin // Then copy all records
            Clear iFromFile
            Send DoLogWork ("   Copying all records." * psText(Self))
            Move ("Copying all records") to sText
            If (pbStatPnl(Self)) Begin
                Set Title_Text of (phoStatPnl(Self)) to sText
            End
            Else Begin
                Set Status_Help to (sText * "for" * psText(Self))
            End
        End 

        Clear iToFile
        If (bOne = True) Begin
            Copy_Records iFromFile to iToFile 1 Using iFromIndex // No callback!
        End
        Else Begin
            Copy_Records iFromFile to iToFile 0 Using iFromIndex Callback Self
        End
    End_Procedure

    // If iRecords = 0 is passed the entire iFromFile will be copied to iToFile.
    // If iRecords > 0  the specified number of iRecords will be copied and this implies
    // that the copy will start with the current record in iFromFile
    Procedure DoCopyManually Integer iFromFile Integer iToFile Boolean bOne Integer iFromIndex Integer iSaveInterval Boolean bDeleteSourceRecords
        Handle ho hoDefaultsArray hoAppendArray hoTransformMainArray hoTransformArray
        Boolean bConstraints bDefaults bTransform bSynchFlags
        Integer iFields iCount iField iFromField iToField iType iToType iRecid iRecordIdentifier iTest
        Integer iRecs iRetval iRecCount iPos iRecIDField
        String sValue sText sAppend sFieldValue sFile sField sRecid sRecIDValue

        Move (oDefaultsArray(Self)) to hoDefaultsArray
        Move (oAppendArray(Self))   to hoAppendArray
        Get pbConstraints           to bConstraints
        Get pbSynchFlags            to bSynchFlags
        Get pbDefaults              to bDefaults
        Get pbTransform             to bTransform
        If (bTransform = True) Begin
            Move (oTransformMainArray(Self)) to hoTransformMainArray
        End

        If (not(bOne)) Begin // Then copy all records
            Get_Attribute DF_FILE_RECORDS_USED of iFromFile to iRecs // Set up number of outer loops
            If (bConstraints) Begin
                Move ("Copying all constrained records") to sText
            End
            Else Begin
                Move ("Copying all records") to sText
            End
            Send DoLogWork ("   " + sText)
            If (pbStatPnl(Self)) Begin
                Set Title_Text of (phoStatPnl(Self)) to sText
            End
            Else Begin
                Set Status_Help to (sText * "for" * psText(Self))
            End
        End

        Get_Attribute DF_FILE_RECORD_IDENTITY of iToFile to iRecordIdentifier

        Move True to Found
        Move (oFieldsArray(Self)) to ho
        Get Item_Count of ho to iFields
        Move -1 to iFromIndex
        If (not(bOne)) Begin
            Constrained_Find First iFromFile by iFromIndex // -1, the index to use will be determined automatically from the constraints in force.
        End

        While (Found)
            If (Found) Begin
                Get_Attribute Df_File_Record_Identity of iFromFile          to iRecIDField
                Get_Field_Value iFromFile iRecIDField                       to sRecIDValue // Gets ID in buffer
                Set psCurrentRecid                                          to sRecIDValue // Class property used by DoLogWork procedure.
                //        If ((Not(bOne) And iSaveInterval)) Begin
                //          If (iSaveCounter = 0) Lock
                //          Increment iSaveCounter
                //        End // If ((Not(bOne) And iSaveInterval)) Begin
                Clear iToFile

                For iCount From 0 to (iFields -1)
                    Get Integer_Value of ho Item iCount                       to iFromField
                    Get_Field_Value iFromFile iFromField                      to sValue
                    Move (Trim(sValue))                                       to sValue
                    Get String_Value of hoAppendArray Item iCount             to sAppend
                    If (Trim(sAppend) <> 0) Begin                             // Then field values in Source table will be appended:
                        Move (sAppend + " ")                                    to sAppend
                        Get_Attribute DF_FIELD_TYPE of iFromFile iFromField     to iType
                        Get Integer_Value of ho Item (iCount + 1)               to iToField
                        Get_Attribute DF_FIELD_TYPE of iToFile iToField         to iToType
                        Repeat
                            Move (Pos(" ", sAppend))                              to iPos
                            If iPos Begin
                                Move (Left(sAppend, (iPos - 1)))                    to iField
                                Move (Replace((String(iField) + " "), sAppend, '')) to sAppend
                                Get_Field_Value iFromFile iField                    to sFieldValue
                                If (iToType = DF_ASCII Or iType = DF_TEXT) ;
                                    Move (String(sValue) * String(sFieldValue))       to sValue
                                Else ;
                                    Move (String(sValue) + String(sFieldValue))       to sValue
                            End
                        Until (sAppend = "" Or Not(iPos))
                    End

                    Get Integer_Value of ho Item (iCount + 1)                 to iToField

                    // Has transformation of field values been used?
                    // Function IsFieldInArray returns the array handle with transformation values
                    // for this field number. If the field has used transformation values, we call
                    // function CheckTransformValues that will substitute to the correct values:
                    If bTransform Begin
                        Get IsFieldInArray of hoTransformMainArray iFromField iToField  to hoTransformArray
                        If hoTransformArray Begin
                            Get TransformValues sValue hoTransformArray to sValue
                        End
                    End

                    Get_Attribute DF_FIELD_TYPE of iToFile iToField             to iType
                    If (iType = DF_BCD) Begin
                        Move (Integer(sValue))                  to sValue
                    End

                    If (iToField = 1 And iRecordIdentifier = 1) Begin
                        Decrement iToField
                    End
                    Set_Field_Value iToFile iToField                            to sValue
                    // Do check to see that the field was properly updated, else log the error:
                    Get_Field_Value iToFile iToField                            to sFieldValue
                    If (Length(Trim(sValue)) > Length(Trim(sFieldValue))) Begin
                        Get psToDataTable                                         to sFile
                        Get_Attribute DF_FIELD_NAME           of iToFile iToField to sField
                        Get_Attribute DF_FILE_RECORD_IDENTITY of iToFile          to iRecid
                        Get_Field_Value iToFile iRecid                            to sRecid
                        If (Length(sValue) > Length(Trim(sFieldValue))) ;
                            Send DoLogWork ("  Warning! New data didn't fit in field/column:" * String(sFile + "." + sField) * "The new value should be:" * String(sValue) ;
                        * "but it is:" * String(sFieldValue) * "Record id:" * String(sRecid))
                        Else ;
                            Send DoLogWork ("  Warning! Could not set new field/column value:" * String(sFile + "." + sField) * "The new value should be:" * String(sValue) ;
                            * "but it is:" * String(sFieldValue) * "Record id:" * String(sRecid))
                    End
                    Increment iCount
                Loop

                // We need to setup default values for fields that is null and that was not handled above:
                If (bDefaults And Not(bTransform)) Begin
                    Get_Attribute DF_FILE_NUMBER_FIELDS of iToFile  to iTest
                    For iCount From 1 to iTest
                        Get_Attribute DF_FIELD_TYPE of iToFile iCount to iType
                        Get_Field_Value iToFile iCount                to sValue
                        Move (Trim(sValue))                           to sValue
                        If (iType = DF_BCD And sValue = "0") Begin
                            Move ""  to sValue // Driver always returns a '0' even if Null.
                        End
                        If (Length(sValue) = 0) Begin
                            Get String_Value of hoDefaultsArray Item (iCount -1) to sFieldValue // The default value.
                            If (sFieldValue = "|") Begin
                                If (iType = DF_ASCII Or iType = DF_TEXT) Begin
                                    Move ""   to sFieldValue
                                End
                                Else Begin
                                    Move 0    to sFieldValue
                                End
                            End
                            If (iType = DF_BCD) Begin
                                Move (Integer(sFieldValue))      to sFieldValue
                            End
                            Set_Field_Value iToFile iCount                       to sFieldValue
                        End
                    Loop
                End

                Set pbSynchErr to False

                SaveRecord iToFile     // SAVE NEW Destination record!

                If Not (pbSynchErr(Self)) Begin
                    Set piCopiedRecords to (piCopiedRecords(Self) + 1)
                    If bSynchFlags Begin
                        Begin_Transaction
                            Send DoUpdateSourceFile iFromFile True // Update Source data table fields (if flag fields has been set).
                        End_Transaction
                    End
                End
            End

            If bOne Begin
                Move False to Found
            End
            Else Begin
                If Not (pbCancelled(Self)) Begin
                    Get CancelCheck to iRetval
                End
                If iRetval Begin
                    Procedure_Return
                End
                Increment iRecCount
                If (bDeleteSourceRecords = True) Begin
                    Delete iFromFile
                    Set piDeletedRecords to (piDeletedRecords(Self) + 1)
                End

                Constrained_Find Next
            End
        End
    End_Procedure

    // Deletes all records from the SOURCE file after updating the target side.
    //  Procedure DoDeleteSourceRecords Integer iFromFile Integer iFromIndex
    //    String sText
    //    Integer iFromField iCount iRetval iSegments iFromRecords iFromRecord iRecords
    //
    //    Move ("  Removing Source records") to sText
    //    Send DoLogWork sText
    //
    //    // Check if iFromFile is empty.
    //    Get_Attribute DF_FILE_RECORDS_USED of iFromFile to iFromRecords
    //    If not iFromRecords Begin
    //      Send DoLogWork "   The Source table was empty. No records to delete."
    //      Procedure_Return
    //    End
    //
    //    If (pbStatPnl(Self)) Begin
    //      Set Action_Text of (phoStatPnl(Self)) to ""
    //      Set Title_Text  of (phoStatPnl(Self)) to (Trim(sText))
    //    End
    //    Else Set Status_Help                    to (sText * "for" * psText(Self))
    //
    //    // Find first record in To-file:
    //    Clear iFromFile
    //    Vfind iFromFile iFromIndex Gt
    //    If not (Found) Begin
    //      Error DfErr_Operator "Index error in 'FromFile'. The table needs to be reindexed."
    //      Procedure_Return
    //    End
    //
    //    // Load FromFile index segments with values from ToFile:
    //    Get Item_Count of oFromIndex to iSegments
    //    While (Found)
    //      // Start with a cleared FromFile:
    //      Clear iFromFile
    //
    //      // All index segments should now be loaded; find FromFile record:
    //      Vfind iFromFile iFromIndex GT
    //      If (Found) Begin
    //        Delete iFromFile
    //        Set piDeletedRecords to (piDeletedRecords(Self) + 1)
    //      End
    //
    //      If (piLicenseType(ghoApplication) = piDemoType(Self) and piDeletedRecords(Self) = piDemoMax(Self)) Procedure_Return  // EVAL license. Stop working.
    //      Add 1 to iFromRecord
    //
    //      If (pbStatPnl(Self)) Send DoUpdateSentinelPercentage iFromRecords iFromRecord
    //      If not (pbCancelled(Self)) Get CancelCheck to iRetval
    //      If iRetval Procedure_Return
    //    Loop
    //  End_Procedure

    // Deletes records in the ToFile that no longer exist in the FromFile:
    Procedure DoDeleteOldRecords Integer iFromFile Integer iFromIndex Integer iToFile Integer iToIndex Integer iSynchType
        Integer iFromField iToField iCount iRetval iSegments iToRecords iToRecord
        String  sToFieldValue sFieldValue
        String  sText

        Move ("  Checking and removing old records") to sText // for" * psText(Self)) to sText
        Send DoLogWork sText

        // Check if iToFile is empty.
        Get_Attribute DF_FILE_RECORDS_USED of iToFile to iToRecords
        If Not iToRecords Begin
            Send DoLogWork "   The Destination table was empty. No records to delete."
            Procedure_Return
        End

        If (pbStatPnl(Self)) Begin
            Set Action_Text of (phoStatPnl(Self)) to ""
            Set Title_Text  of (phoStatPnl(Self)) to (Trim(sText))
            Send DoAdvance  of ghoProgressBar
        End
        Else Begin
            Set Status_Help to (sText * "for" * psText(Self))
        End

        // Find first record in To-file:
        Clear iToFile
        VFind iToFile iToIndex Gt
        If Not (Found) Begin
            Error DfErr_Operator "Index error in 'ToFile'. The table needs to be reindexed."
            Procedure_Return // We have previously checked that records exist in this file, so must be index error.
        End

        // Load FromFile index segments with values from ToFile:
        Get Item_Count of oFromIndex to iSegments
        While (Found)
            Move "" to sToFieldValue
            // Start with a cleared FromFile:
            Clear iFromFile
            For iCount From 0 to (iSegments -1)
                Get Integer_Value                of oFromIndex Item iCount to iFromField
                Get Integer_Value of oIndexArrayFromString Item iCount to iToField
                If (iFromField < 0 Or iToField < 0) Begin
                    Error DfErr_Operator ("An error occured while initializing the FromFile index field(s) to find records to delete." * "Index load fields: iFrom field =" * String(iFromField) * "iTo field =" * String(iToField))
                    Procedure_Return
                End
                Get_Field_Value iToFile iToField     to sFieldValue
                Move (Trim(sFieldValue))             to sFieldValue
                Set_Field_Value iFromFile iFromField to sFieldValue
            Loop

            // All index segments should now be loaded; find FromFile record:
            VFind iFromFile iFromIndex Eq
            // Not found in FromFile, delete ToFile record:
            If Not (Found) Begin
                Delete iToFile
                Set piDeletedRecords to (piDeletedRecords(Self) + 1)
            End

//            If (piLicenseType(ghoApplication) = piDemoType(Self) And piDeletedRecords(Self) = piDemoMax(Self)) Begin
//                Procedure_Return  // EVAL license. Stop working.
//            End
            VFind iToFile iToIndex Gt  // Find next ToFile record.
            Add 1 to iToRecord

            If (pbStatPnl(Self)) Begin
                Send DoUpdateSentinelPercentage iToRecords iToRecord
            End
            If Not (pbCancelled(Self)) Begin
                Get CancelCheck to iRetval
            End
            If iRetval Begin
                Procedure_Return
            End
        Loop

    End_Procedure

    // If pbSynchFlags is True, update field/fields in the Source data table:
    Procedure DoUpdateSourceFile Integer iFile Boolean bLock
        Handle ho
        Boolean bSave
        Integer iCount iItems iField iPos iStart iTranCount
        String sValue sFlagVal sOldVal

        If not (pbSynchFlags(Self)) Begin
            Procedure_Return
        End
        Move (oSynchFlagsArray(Self)) to ho
        Get_Attribute DF_TRAN_COUNT   to iTranCount

        Get Item_Count of ho to iItems
        //        If (pbStatPnl(Self)) Begin
        //            Send DoAdvance of ghoProgressBar
        //        End

        If bLock Begin
            // Reread iFile    // Reread Source record. *** THIS WON'T WORK FOR UNIQUE "ASCII" INDEXES!!! (So don't use)****
            VFind iFile 0 Eq
        End

        Move 0 to iStart
        For iCount From iStart to (iItems - 1)
            Get String_Value of ho Item iCount                  to sValue
            Move (Pos(" ", sValue))                             to iPos
            If iPos Begin
                Move (Left(sValue, (iPos - 1)))                 to iField          // Get the field number.
                Move (Right(sValue, (Length(sValue) - iPos)))   to sValue          // Remove the field number.
                Move (Pos("|", sValue))                         to iPos            // Only if more than one flag field has been defined.
                If iPos Begin
                    Move (Left(sValue, (iPos - 1)))               to sFlagVal
                    Move (Right(sValue, (Length(sValue) - iPos))) to sValue          // Remove the field value.
                End
                Else Begin
                    Move sValue                                 to sFlagVal
                End

                // Get current field/column value:
                Get_Field_Value iFile iField                    to sOldVal
                Move (sOldVal <> sFlagVal)                      to bSave
                If bSave Begin
                    // Change current field/column value:
                    Set_Field_Value iFile iField                to sFlagVal        // CHANGE Source data table field value!
                End
                // showln "Field = " iField " sFlagVal = " sFlagVal
            End
        Loop

        If bSave Begin
            SaveRecord iFile
            // *** TEMPORARY FIX ***
            // This should be done for _all_ flag fields, right now it only
            // works if one flag field is used:
            Set_Field_Value iFile iField                  to sOldVal        // CHANGE Source data table field value!
            Set_Attribute DF_FILE_CHANGED of iFile        to False          // Reset file record buffer flag.
            // send dologwork "source record was saved"
        End
    End_Procedure

    // Used by the Compare procedure.
    // Parameters: Current Field values for the Source table and the Destination table and an array handle.
    // The from values in the array are compared with the passed sFromValue and if there's a match,
    // the sToValue is swithed with the array value.
    // Returns the new sFromValue if the array contained the sFromValue, else returns
    // the sFromValue unchanged.
    Function CheckTransformValues String sFromValue String sToValue Handle TransformArray Returns String
        Integer iCount iItems iPos iCase
        String sValue sTransformFrom sTransformTo

        Move (Trim(sFromValue)) to sFromValue
        Move (Trim(sToValue))   to sToValue
        Get Item_Count of TransformArray to iItems
        For iCount From 0 to (iItems - 1)
            Get String_Value of TransformArray Item iCount to sValue
            // This is how the sValue is build in the array:
            // SncTHea.FromField * SncTHea.ToField * SncTRow.IgnoreCase * sFromValue + "|" + sToValue
            Move (Pos(" ", sValue))                            to iPos
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // First remove the From field number, we don't need it here,
            Move (Pos(" ", sValue))                            to iPos
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // Then remove the to field number, we don't need it here,
            Move (Pos(" ", sValue))                            to iPos
            Move (Left(sValue, (iPos - 1)))                    to iCase
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // then remove the Ignore_Case value,
            Move (Pos("|", sValue))                            to iPos
            Move (Left(sValue, (iPos - 1)))                    to sTransformFrom  // get the TransformFrom value,
            Move (Right(sValue, (Length(sValue) - iPos)))      to sTransformTo    // and finally get the TransformTo value.
            //      showln "sFromValue = " sFromValue " sTransformFrom = " sTransformFrom " sToValue = " sToValue " sTransformTo = " sTransformTo " hoTransformArray = " hoTransformArray
            If (not(iCase) and sFromValue = sTransformFrom and sFromValue <> sTransformTo) Begin
                Function_Return sTransformTo
            End
            If (iCase and Uppercase(sFromValue) = Uppercase(sTransformFrom) and Uppercase(sFromValue) <> Uppercase(sTransformTo)) Begin
                Function_Return sTransformTo
            End
        Loop
        Function_Return sFromValue
    End_Function

    // Used by CopyManually procedure to transform ToValues.
    // Parameters: Current Field value for the Source table and array handle.
    // Returns the new sFromValue if the array contained the sFromValue, else returns
    // the sFromValue unchanged.
    Function TransformValues String sFromValue Handle hoTransformArray Returns String
        Integer iCount iItems iPos iCase
        String sValue sTransformFrom sTransformTo

        Get Item_Count of hoTransformArray to iItems
        For iCount From 0 to (iItems - 1)
            Get String_Value of hoTransformArray Item iCount   to sValue
            Move (Pos(" ", sValue))                            to iPos
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // First remove the field number, we don't need it here,
            Move (Pos(" ", sValue))                            to iPos
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // Then remove the to field number, we don't need it here,
            Move (Pos(" ", sValue))                            to iPos
            Move (Left(sValue, (iPos - 1)))                    to iCase
            Move (Right(sValue, (Length(sValue) - iPos)))      to sValue          // then remove the Ignore_Case value.
            Move (Pos("|", sValue))                            to iPos
            Move (Left(sValue, (iPos - 1)))                    to sTransformFrom
            Move (Right(sValue, (Length(sValue) - iPos)))      to sTransformTo
            If (not(iCase) and sFromValue = sTransformFrom  and sFromValue <> sTransformTo) Begin
                Function_Return sTransformTo
            End
            If (iCase and Uppercase(sFromValue) = Uppercase(sTransformFrom) and Uppercase(sFromValue) <> Uppercase(sTransformTo)) Begin
                Function_Return sTransformTo
            End
        Loop

        Function_Return sFromValue
    End_Function

    // Checks for database integrity i.e. that not one of the fields involved in the synzhronization
    // process has changed.
    // Returns True if "successful". I.e. the synchronization process should be run.
    //         False if failed. Then a warning msg is changed to the log file.
    Function CheckIntegrity Integer iFromFile Integer iToFile String sFromLayout String sToLayout Returns Integer
        Integer iRetval iStart iEnd iPos

        If (not(pbCheckIntegrity(Self))) Begin
            Function_Return True
        End
        If (Length(sFromLayout) = 0 or Length(sToLayout) = 0) Begin
            Send DoLogWork ("   Warning! 'Check For Database Table Layout Changes before Connecting' has been set to on but the 'snapshot' of the databases has not been performed in the RDC Main Setup program.")
            Function_Return (False)
        End
        Move (Pos(" ", sFromLayout))         to iPos
        Move (Left(sFromLayout, (iPos - 1))) to iStart
        Get CheckNoOfFields sFromLayout      to iEnd
        Get IsCheckIntegrity iFromFile iStart iEnd sFromLayout to iRetval
        If (iRetval) Begin
            Send DoLogWork ("   Warning! The database layout has changed for Source table. No connection was performed.")
            Function_Return (False)
        End
        Else Begin
            Send DoLogWork ("   'Database Table Layout Changes' was checked for the Source table. It was ok.")
        End
        Move (Pos(" ", sToLayout))           to iPos
        Move (Left(sToLayout, (iPos - 1)))   to iStart
        Get CheckNoOfFields sToLayout        to iEnd
        Get IsCheckIntegrity iToFile iStart iEnd sToLayout to iRetval
        If (iRetval) Begin
            Send DoLogWork ("   Warning! The database layout has changed for Destination table. No connection was performed.")
            Function_Return (False)
        End
        Else Begin
            Send DoLogWork ("   'Database Table Layout Changes' was checked for the Destination table. It was ok.")
        End
        Function_Return (True)
    End_Function

    // Help function for the CheckIntegrity function.
    // Returns True if any field has changed.
    //         False if all fields are the same.
    Function IsCheckIntegrity Integer iFile Integer iStart Integer iEnd String sLayout Returns Integer
        Integer iType iLength iPrec iTypeOrg iLengthOrg iPrecOrg iCount iPos iRetval iField
        String sSub

        Move (sLayout - "|") to sLayout
        For iCount From iStart to iEnd
            Get_Attribute DF_FIELD_TYPE      of iFile iCount to iType
            Get_Attribute DF_FIELD_LENGTH    of iFile iCount to iLength
            Get_Attribute DF_FIELD_PRECISION of iFile iCount to iPrec
            Move (Pos("|", sLayout))          to iPos
            Move (Left(sLayout, (iPos - 1))) to sSub
            Move (Right(sLayout, (Length(sLayout) - iPos)))  to sLayout
            Move (Pos(" ", sSub))            to iPos
            Move (Left(sSub, (iPos - 1)))    to iField
            Move (Right(sSub, (Length(sSub) - iPos)))        to sSub
            Move (Pos(" ", sSub))            to iPos
            Move (Left(sSub, (iPos - 1)))    to iTypeOrg
            Move (Right(sSub, (Length(sSub) - iPos)))        to sSub
            Move (Pos(" ", sSub))            to iPos
            Move (Left(sSub, (iPos - 1)))    to iLengthOrg
            Move (Right(sSub, (Length(sSub) - iPos)))        to sSub
            Move (Trim(sSub))                to iPrecOrg
            //showln "iType = " iType " iTypeOrg = " iTypeOrg " iLength = " iLength " iLengthOrg = " iLengthOrg " iPrec = " iPrec " iPrecOrg = " iPrecOrg
            If (iType <> iTypeOrg or iLength <> iLengthOrg or iPrec <> iPrecOrg) Begin
                Move (True) to iRetval
            End
            If iRetval Break
        Loop
        Function_Return iRetval
    End_Function

    Function CheckNoOfFields String sSelFields Returns Integer
        Integer iRetval iPos

        Move (Trim(sSelFields)) to sSelFields
        If (Length(sSelFields) = 0) Begin
            Function_Return 0
        End
        Move (Pos("|", sSelFields)) to iPos
        If not iPos Begin
            Function_Return 1  // Necessary if only one field.
        End
        Repeat
            Move (Replace("|", sSelFields, "")) to sSelFields
            Increment iRetval
        Until (not(Pos("|", sSelFields)))

        Increment iRetval
        Function_Return iRetval
    End_Function

    // Do what we can to force the status panel to the top. If the main program gets
    // the focus force the status panel to take the focus.
    // 2016-08-16 NGS. Don't think this is needed anymore.
    Procedure DoStatusPaneltoForeground
        //        Handle hwStat hwMain hMain
        //        Get Main_Window to hMain
        //        If not hMain Begin
        //            Broadcast Get Main_Window to hMain
        //        End
        //        If hMain Begin
        //            Get Window_Handle of hMain to hwMain
        //        End
        //        If hwMain Begin
        //          If (GetForegroundWindow() = hwMain) Begin
        //              Move (SentinelWindow(Desktop)) to hwStat
        //              If hwStat Begin
        //                  Move (SetForegroundWindow(hwStat)) to hwStat
        //              End
        //          End
        //        End
    End_Procedure

    Function CancelCheck Returns Integer
        Integer iRetval
        String sTitle sMessage sAction

        If (pbStatPnl(Self)) Begin
            Send DoStatusPanelToForeground
            Get Check_StatusPanel of (phoStatPnl(Self)) to iRetval
        End
        If iRetval Begin
            Get Title_Text        of (phoStatPnl(Self)) to sTitle
            Get Message_Text      of (phoStatPnl(Self)) to sMessage
            Get Action_Text       of (phoStatPnl(Self)) to sAction
            Send Stop_StatusPanel of (phoStatPnl(Self))
            Get YesNo_Box "Cancel Connect Engine process?" "" MB_DEFBUTTON2 to iRetval
            If (iRetval = MBR_Yes) Begin
                Set pbCancelled to (True)
                Function_Return (True)
            End
            Else If (pbStatPnl(Self)) Begin
                Send Start_StatusPanel of (phoStatPnl(Self))
                Set Title_Text        of (phoStatPnl(Self)) to sTitle
                Set Message_Text      of (phoStatPnl(Self)) to sMessage
                Set Action_Text       of (phoStatPnl(Self)) to sAction
                //                Send DoAdvance        of ghoProgressBar
            End
        End
        Function_Return (False)
    End_Function

    // We take care of all errors in the Error_Report below and
    // collect them all to an array property. So just ignore any
    // "Ignore_Error" & "Trap_Error" messages that might be send/used
    // in some other package.
    Procedure Ignore_Error Integer iError
    End_Procedure

    Procedure Trap_Error Integer iError
    End_Procedure

    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrorText
        String sDFErrorText

        If (Error_Processing_State(Self)) Begin
            Procedure_Return
        End
        If (iErrNum = 4100 or iErrNum = 4121 or iErrNum = 0) Begin
            Procedure_Return
        End
        Set Error_Processing_State to True
        Set piErrorCount to (piErrorCount(Self) + 1)
        If (Length(sErrorText) = 0) Begin
            Get Error_Description of (piOldErrorId(Self)) iErrNum iErrLine to sErrorText
            Move (Trim(Replace(iErrLine, sErrorText, ""))) to sErrorText
        End
        If (iErrNum < 4097) Begin
            Move iErrNum to FlexErrs.Recnum
            Find Eq FlexErrs by Recnum
            If (Found) Begin
                Move (Trim(FlexErrs.Error_Descr)) to sDFErrorText
            End
        End

        Send DoLogWork ("   Error:" * "'" + String(sErrorText) + "'" * "No:" * String(iErrNum) * String(sDFErrorText) * "(on line:" * String(iErrLine) + ")")

        Set Error_Processing_State to False
        Move False to Err
        Set pbSynchErr to True
    End_Procedure

    Procedure DoLogWork String sStatusText
        Integer hDD
        String sCurrentRecid
        DateTime dtCurrentDateTime

        Get psCurrentRecid       to sCurrentRecid
        Move (CurrentDateTime()) to dtCurrentDateTime
        Move (SncLog_DD(Self))   to hDD
        Send Clear               of hDD
        If (sStatusText contains "Field cannot be updated") Begin
            Move (sStatusText * "You probably need to set the 'DUMMY_UPDATE_COLUMN' keyword to a proper column number for the Destination table's .INT file.") to sStatusText
        End
        If (sStatusText contains "Please enter a number" and psToFileDriver(Self) = ODBC_DRV_ID) Begin
            Move (sStatusText * "You probably need to set the 'PATCH2' keyword in the db2cli.ini file, to be able to handle decimal numbers with the ODBC CK driver and IBM DB2 databases.") to sStatusText
        End
        If (Uppercase(sStatusText) contains "ERROR") Begin
            Move (sStatusText * "(Source Table Record id:" * String(sCurrentRecid) + ")") to sStatusText
        End
        Set Field_Changed_Value of hDD Field SncLog.StatusText to sStatusText
#IF (!@ < 230)
        Set Field_Changed_Value of hDD Field SncLog.TableName to (ToOem(psText(Self)))
        Set Field_Changed_Value of hDD Field SncLog.SncTableSortField to (ToOem(psSncTableSortText(Self)))
        Set Field_Changed_Value of hDD Field SncLog.SncTableSortField to (ToOem(psSncTableSortText(Self)))
#ELSE
        Set Field_Changed_Value of hDD Field SncLog.TableName to (Utf8ToOem(psText(Self)))
        Set Field_Changed_Value of hDD Field SncLog.SncTableSortField to (Utf8ToOem(psSncTableSortText(Self)))
        Set Field_Changed_Value of hDD Field SncLog.SncTableSortField to (Utf8ToOem(psSncTableSortText(Self)))
#ENDIF
        Set Field_Changed_Value of hDD Field SncLog.DateTimeCreated to dtCurrentDateTime
        Set Field_Changed_Value of hDD Field SncLog.NetworkUserName to (psUser(Self))
        Send Request_Save       of hDD
    End_Procedure

End_Class
